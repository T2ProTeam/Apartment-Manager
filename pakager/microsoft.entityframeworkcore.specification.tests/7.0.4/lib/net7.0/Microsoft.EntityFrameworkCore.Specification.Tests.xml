<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.EntityFrameworkCore.Specification.Tests</name>
    </assembly>
    <members>
        <member name="M:Microsoft.EntityFrameworkCore.OptimisticConcurrencyTestBase`2.ConcurrencyTestAsync(System.Action{Microsoft.EntityFrameworkCore.TestModels.ConcurrencyModel.F1Context},System.Action{Microsoft.EntityFrameworkCore.TestModels.ConcurrencyModel.F1Context,Microsoft.EntityFrameworkCore.DbUpdateConcurrencyException},System.Action{Microsoft.EntityFrameworkCore.TestModels.ConcurrencyModel.F1Context})">
            <summary>
                Runs the same action twice inside a transaction scope but with two different contexts and calling
                SaveChanges such that first time it will succeed and then the second time it will result in a
                concurrency exception.
                After the exception is caught the resolver action is called, after which SaveChanges is called
                again.  Finally, a new context is created and the validator is called so that the state of
                the database at the end of the process can be validated.
            </summary>
        </member>
        <member name="M:Microsoft.EntityFrameworkCore.OptimisticConcurrencyTestBase`2.ConcurrencyTestAsync(System.Action{Microsoft.EntityFrameworkCore.TestModels.ConcurrencyModel.F1Context},System.Action{Microsoft.EntityFrameworkCore.TestModels.ConcurrencyModel.F1Context},System.Action{Microsoft.EntityFrameworkCore.TestModels.ConcurrencyModel.F1Context,Microsoft.EntityFrameworkCore.DbUpdateConcurrencyException},System.Action{Microsoft.EntityFrameworkCore.TestModels.ConcurrencyModel.F1Context})">
            <summary>
                Runs the two actions with two different contexts and calling
                SaveChanges such that storeChange will succeed and the store will reflect this change, and
                then clientChange will result in a concurrency exception.
                After the exception is caught the resolver action is called, after which SaveChanges is called
                again. Finally, a new context is created and the validator is called so that the state of
                the database at the end of the process can be validated.
            </summary>
        </member>
        <member name="M:Microsoft.EntityFrameworkCore.OptimisticConcurrencyTestBase`2.ConcurrencyTestAsync``1(System.Action{Microsoft.EntityFrameworkCore.TestModels.ConcurrencyModel.F1Context},System.Action{Microsoft.EntityFrameworkCore.TestModels.ConcurrencyModel.F1Context},System.Action{Microsoft.EntityFrameworkCore.TestModels.ConcurrencyModel.F1Context,``0},System.Action{Microsoft.EntityFrameworkCore.TestModels.ConcurrencyModel.F1Context})">
            <summary>
                Runs the two actions with two different contexts and calling
                SaveChanges such that storeChange will succeed and the store will reflect this change, and
                then clientChange will result in a concurrency exception.
                After the exception is caught the resolver action is called, after which SaveChanges is called
                again. Finally, a new context is created and the validator is called so that the state of
                the database at the end of the process can be validated.
            </summary>
        </member>
        <member name="T:Microsoft.EntityFrameworkCore.TestUtilities.Xunit.ConditionalFactDiscoverer">
            <summary>
                Used dynamically from <see cref="T:Xunit.ConditionalFactAttribute" />.
                Make sure to update that class if you move this type.
            </summary>
        </member>
        <member name="T:Microsoft.EntityFrameworkCore.TestUtilities.Xunit.ConditionalTheoryDiscoverer">
            <summary>
                Used dynamically from <see cref="T:Xunit.ConditionalTheoryAttribute" />.
                Make sure to update that class if you move this type.
            </summary>
        </member>
        <member name="M:System.SharedTypeExtensions.DisplayName(System.Type,System.Boolean,System.Boolean)">
            <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        </member>
    </members>
</doc>
